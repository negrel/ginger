package observables

import (
	"github.com/negrel/debuggo/pkg/assert"
)

// InvalidationHandler is called whenever an Observable becomes invalid.
type InvalidationHandler *func(Observable)

// Observable is a generic interface implemented by all Observable types.
type Observable interface {
	AddInvalidationHandler(...InvalidationHandler)
	RemoveInvalidationHandler(...InvalidationHandler)
}

var _ Observable = &observable{}

type observable struct {
	ptr				  Observable
	invalidationHandlers map[InvalidationHandler]struct{}
}

// NewObservable returns a new instantiated Observable.
func NewObservable() Observable {
	o := newCompositeObservable(nil)
	o.ptr = o

	return o
}

// NewCompositeObservable returns a new Observable object. Unlike NewObservable,
// this function returns an Observable object that can be used in composite struct. The ptr argument
// must be a pointer to the composite struct. Therefore, invalid handler will receive a pointer to the composite
// struct when this Observable will become invalid.
func NewCompositeObservable(ptr Observable) Observable {
	return newCompositeObservable(ptr)
}

func newCompositeObservable(ptr Observable) *observable {
	return &observable{
		ptr:				  ptr,
		invalidationHandlers: make(map[InvalidationHandler]struct{}),
	}
}

// AddInvalidationHandler implements the Observable interface.
func (o observable) AddInvalidationHandler(handlers ...InvalidationHandler) {
	assert.True(o.isValid())

	for _, handler := range handlers {
		o.invalidationHandlers[handler] = struct{}{}
	}
}

// RemoveInvalidationHandler implements the Observable interface.
func (o observable) RemoveInvalidationHandler(handlers ...InvalidationHandler) {
	assert.True(o.isValid())

	for _, handler := range handlers {
		_, ok := o.invalidationHandlers[handler]
		if ok {
			delete(o.invalidationHandlers, handler)
		}
	}
}

func (o observable) invalid() {
	for handler := range o.invalidationHandlers {
		(*handler)(o.ptr)
	}

	o.invalidationHandlers = nil
}

func (o observable) isValid() bool {
	return o.invalidationHandlers != nil
}

{{ range . }}
{{ $type := . -}}
{{- $Type :=  . | title -}}

{{ if eq $type "interface{}" }}
{{ $Type = "Object" }}
{{ end }}

{{- $TypeChangeHandler := printf "%sChangeHandler" $Type -}}
{{- $ObservableType := printf "Observable%s" $Type -}}

// {{ $TypeChangeHandler }} is called whenever the value of an {{ $ObservableType }} change.
type {{ $TypeChangeHandler }} *func(observable {{ $ObservableType }}, old, new {{ $type }})

// {{ $ObservableType }} is an entity that wraps a value of type {{ $type }} and allows to observe value changes.
type {{ $ObservableType }} interface {
	Observable

	Get() {{ $type }}
	Set({{ $type }})

	AddChangeHandler(...{{ $TypeChangeHandler }})
	RemoveChangeHandler(...{{ $TypeChangeHandler }})
}

{{ $observableType := printf "observable%s" $Type -}}
var _ {{ $ObservableType }} = &{{ $observableType }}{}

type {{ $observableType }} struct {
	*observable

	data   {{ $type }}
	handlers map[{{ $TypeChangeHandler }}]struct{}
}

// New{{ $ObservableType }} returns a new instantiated {{ $ObservableType }}.
func New{{ $ObservableType }}(data {{ $type }}) {{ $ObservableType }} {
	oo := newComposite{{ $ObservableType }}(nil, data)
	oo.ptr = oo

	return oo
}

// NewComposite{{ $ObservableType }} returns a new {{ $ObservableType }} object. Unlike New{{ $ObservableType }},
// this function returns an {{ $ObservableType }} object that can be used in composite struct. The ptr argument
// must be a pointer to the composite struct. Therefore, invalid handler will receive a pointer to the composite
// struct when this {{ $ObservableType }} will become invalid.
func NewComposite{{ $ObservableType }}(data {{ $type }}) {{ $ObservableType }} {
	oo := newComposite{{ $ObservableType }}(nil, data)
	oo.ptr = oo

	return oo
}

func newComposite{{ $ObservableType }}(ptr {{ $ObservableType }}, data {{ $type }}) *{{ $observableType }} {
	return &{{ $observableType }}{
		observable: newCompositeObservable(ptr),
		data:	   data,
		handlers:   make(map[{{ $TypeChangeHandler }}]struct{}),
	}
}

// Get implements the {{ $ObservableType }} interface.
func (oo *{{ $observableType }}) Get() {{ $type }} {
	assert.True(oo.isValid())

	return oo.data
}

// Set implements the {{ $ObservableType }} interface.
func (oo *{{ $observableType }}) Set(newValue {{ $type }}) {
	assert.True(oo.isValid())

	old := oo.data
	oo.data = newValue
	for handler := range oo.handlers {
		(*handler)(oo, old, newValue)
	}
}

// AddChangeHandler implements the {{ $ObservableType }} interface.
func (oo *{{ $observableType }}) AddChangeHandler(handlers ...{{ $TypeChangeHandler }}) {
	assert.True(oo.isValid())

	for _, handler := range handlers {
		oo.handlers[handler] = struct{}{}
	}
}

// RemoveChangeHandler implements the {{ $ObservableType }} interface.
func (oo *{{ $observableType }}) RemoveChangeHandler(handlers ...{{ $TypeChangeHandler }}) {
	assert.True(oo.isValid())

	for _, handler := range handlers {
		_, ok := oo.handlers[handler]
		if ok {
			delete(oo.handlers, handler)
		}
	}
}

{{ $TypeBinding := printf "%sBinding" $Type -}}

// {{ $TypeBinding }} define the minimum required to implement a binding to {{ $type }}.
type {{ $TypeBinding }} interface {
	{{ $ObservableType }}

	// Dispose signals to the bindings that it will not be used anymore
	// and any references can be removed.
	Dispose()

	// GetDependencies returns the all the dependencies of this binding.
	GetDependencies() []{{ $ObservableType }}

	// Bind starts observing the dependencies for change.
	Bind(...{{ $ObservableType }})

	// Unbind stops observing the dependencies for change.
	Unbind(...{{ $ObservableType }})
}

{{- $typeBinding := printf "%sBinding" $type -}}
{{ if eq $type "interface{}" }}
{{- $typeBinding = "objectBinding" -}}
{{ end }}

var _ {{ $TypeBinding }} = &{{ $typeBinding }}{}

type {{ $typeBinding }} struct {
	*{{ $observableType }}

	dependencies []{{ $ObservableType }}
}

func New{{ $TypeBinding }}(data {{ $type }}) {{ $TypeBinding }} {
	ob := newComposite{{ $TypeBinding }}(nil, data)
	ob.ptr = ob

	return ob
}

func NewComposite{{ $TypeBinding }}(ptr {{ $TypeBinding }}, data {{ $type }}) {{ $TypeBinding }} {
	return newComposite{{ $TypeBinding }}(ptr, data)
}

func newComposite{{ $TypeBinding }}(ptr {{ $TypeBinding }}, data {{ $type }}) *{{ $typeBinding }} {
	return &{{ $typeBinding }}{
		{{ $observableType }}: newCompositeObservable{{ $Type }}(ptr, data),
		dependencies: make([]{{ $ObservableType }}, 0, 8),
	}
}

func (ob *{{ $typeBinding }}) Dispose() {
	assert.True(ob.isValid())

	ob.invalid()
	ob.dependencies = nil
}

func (ob *{{ $typeBinding }}) GetDependencies() []{{ $ObservableType }} {
	assert.True(ob.isValid())

	return ob.dependencies
}

func (ob *{{ $typeBinding }}) Bind(observables ...{{ $ObservableType }}) {
	assert.True(ob.isValid())

	for _, observable := range observables {
		ob.dependencies = append(ob.dependencies, observable)

		invalidationHandler := func(_ Observable) {
			ob.Unbind(observable)
		}

		observable.AddInvalidationHandler(&invalidationHandler)

		changeHandler := func(_ {{ $ObservableType }}, oldValue, newValue {{ $type }}) {
			if newValue == ob.Get() {
				return
			}

			ob.Set(newValue)
		}

		observable.AddChangeHandler(&changeHandler)
	}
}

func (ob *{{ $typeBinding }}) Unbind(observables ...{{ $ObservableType }}) {
	assert.True(ob.isValid())

	for _, toUnbind := range observables {
		for i, observable := range ob.dependencies {
			if toUnbind == observable {
				ob.dependencies[i] = ob.dependencies[len(ob.dependencies)-1]
				ob.dependencies = ob.dependencies[:len(ob.dependencies)-1]
			}
		}
	}
}

{{ end }}
